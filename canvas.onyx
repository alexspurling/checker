use core {println, printf}
use core.math

CANVAS_SIZE :: 800;
CANVAS_BUFFER_SIZE :: CANVAS_SIZE * CANVAS_SIZE * 4; // 4 bytes per pixel
CANVAS_BUFFER_POINTER: [CANVAS_BUFFER_SIZE] u8;

FONT :: #file_contents "monaco16.bmp"
FONT_IMAGE :: FONT[cast(u32) FONT[0xA] .. FONT.count]; // The byte at 0xA tells us where the RGB image data begins

grid: [100] [100] i32;


FontSheet :: struct {
    width: i32;
    height: i32;
    charWidth: i32;
    charHeight: i32;
    sheetWidth: i32;
    sheetHeight: i32;
}

FONT_SHEET :: FontSheet.{320, 51, 10, 17, 32, 3};

// getIntFromArray :: (arr: [] u8, offset: i32) -> i32 {
//     a: u32 = cast(u32, arr[offset + 3]) << 24;
//     b: u32 = cast(u32, arr[offset + 2]) << 16;
//     c: u32 = cast(u32, arr[offset + 1]) << 8;
//     d: u32 = cast(u32, arr[offset + 0]);
//     return a | b | c | d;
// }

// getFontSheet :: () -> FontSheet {
//     width := getIntFromArray(FONT, 0x12);
//     height := getIntFromArray(FONT, 0x16);
//     return FontSheet.{width, height, 10, 17, 32, 3};
// }


#export "getBufferSize" getBufferSize
getBufferSize :: () -> i32 {
    return CANVAS_BUFFER_SIZE;
}

#export "getBufferPointer" getBufferPointer
getBufferPointer :: () -> rawptr {
    return &CANVAS_BUFFER_POINTER;
}

Colour :: struct {
    r: u8;
    g: u8;
    b: u8;
    a: u8;
}

// Font sheet:
//  !"#$%&'()*+,-./0123456789:;<=>?
// @ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_
// `abcdefghijklmnopqrstuvwxyz{|}~

#export "render" render
render :: (time: i64) -> i32 {

    // foregroundR: u8 = cast(u8)(time % 256);
    // foregroundG: u8 = cast(u8)((time >> 1) % 256);
    // foregroundB: u8 = cast(u8)((time >> 2) % 256);

    // backgroundR: u8 = cast(u8)((time >> 3) % 256);
    // backgroundG: u8 = cast(u8)((time >> 4) % 256);
    // backgroundB: u8 = cast(u8)((time >> 5) % 256);

    // foreground := Colour.{foregroundR, foregroundG, foregroundB, 255};
    // background := Colour.{backgroundR, backgroundG, backgroundB, 255};

    // fontSheet := getFontSheet();

    // printf("Sheet: {}\n", fontSheet);

    // printf("Font: {}, {}, {}, {}, {}, {}, {}\n", fontSheet.width, fontSheet.height, fontSheet.charWidth, fontSheet.charHeight, 
    //     fontSheet.sheetWidth, fontSheet.sheetHeight, FONT.count);

    tileSize := 20;

    for y: 0 .. 46 {
        for x: 0 .. 78 {
            posX := 10 + x * 10;
            posY := 10 + y * 17;

            charToRender := cast(u8) ('0' + grid[y][x]);
            renderChar(charToRender, posX, posY);
        }
    }

    // for y: 0 .. 800 {
    //     for x: 0 .. 800 {
    //         setPixel(x, y, Colour.{200, 40, 0, 255});
    //     }
    // }


    return cast(i32) CANVAS_BUFFER_POINTER[968 + 4];
}

renderChar :: (char: u8, xPos: i32, yPos: i32) {
    for y: 0 .. FONT_SHEET.charHeight {
        for x: 0 .. FONT_SHEET.charWidth {
            setPixel(xPos + x, yPos + y, getFontPixel(char, x, y));
        }
    }
}

getFontPixel :: (char: u8, x: i32, y: i32) -> Colour {
    // Need to subtract the y coord from the sheet height because for some reason
    // BMP files store images from bottom to top
    charX := cast(i32, (char - ' ')) % FONT_SHEET.sheetWidth;
    charY := cast(i32, (char - ' ')) / FONT_SHEET.sheetWidth;
    fontIdx := (charX * FONT_SHEET.charWidth + x + ((FONT_SHEET.height - 1 - y - (charY * FONT_SHEET.charHeight)) * FONT_SHEET.width)) * 4;

    // fontCount := FONT_IMAGE.count;
    // if (fontCount != 65280) {
    //     printf("Image is wrong size: {}\n", fontCount);
    // } elseif (fontIdx < 0 || fontIdx > fontCount - 4) {
    //     printf("Uh how somehow we got the wrong index: {}, {}, {}, {}, {}, {}, {}, {}\n", 
    //     fontIdx, x, y, FONT_SHEET.sheetWidth, FONT_SHEET.sheetHeight, FONT_SHEET.charHeight, FONT_SHEET.width, FONT_SHEET.height);
    // }
    fontColourR := FONT_IMAGE[fontIdx];
    fontColourG := FONT_IMAGE[fontIdx + 1];
    fontColourB := FONT_IMAGE[fontIdx + 2];
    fontColourA := FONT_IMAGE[fontIdx + 3];

    return Colour.{fontColourA, fontColourG, fontColourB, fontColourA};
}

setPixel :: (x: i32, y: i32, pixel: Colour) {
    bufferIdx := (y * CANVAS_SIZE + x) * 4;
    if bufferIdx >= 0 && bufferIdx <= CANVAS_BUFFER_SIZE - 4 {
        CANVAS_BUFFER_POINTER[bufferIdx + 0] = pixel.r;
        CANVAS_BUFFER_POINTER[bufferIdx + 1] = 0;
        CANVAS_BUFFER_POINTER[bufferIdx + 2] = 0;
        CANVAS_BUFFER_POINTER[bufferIdx + 3] = pixel.a;
    } else {
        printf("Setting pixel out of bounds: x: {}, y: {}, idx: {}\n", x, y, bufferIdx);
    }
}
