#load "canvas.onyx"
#load "common.onyx"
#load "strings.onyx"


use core
use core.iter
use core.map
use core.string
use core.array
use core.set
use core.conv {parse_int}
use common {Pos, cmp}
use strings {toStr}
use core {println, printf}
use core.heap
use core.hash
use core.intrinsics.atomics {__atomic_wait, __atomic_notify, __atomic_cmpxchg, __atomic_store}


Node :: struct {
    pos: Pos;
    distance: i32;
}
#operator == (n1: Node, n2: Node) -> bool {
    return n1.pos == n2.pos && n1.distance == n2.distance;
}
#operator < (n1: Node, n2: Node) -> bool {
    return n1.distance < n2.distance;
}

MAX_INT :: 2000000000;


getNeighbours :: (p: Pos) -> [..] Pos {
    neighbours := array.make(Pos, allocator=context.temp_allocator); // Todo check if we need to use the temp allocator here

    neighbours << Pos.{p.x - 1, p.y};
    neighbours << Pos.{p.x + 1, p.y};
    neighbours << Pos.{p.x, p.y - 1};
    neighbours << Pos.{p.x, p.y + 1};

    return neighbours;
}


getCityCost :: (city: [] str, pos: Pos) -> i32 {
    costChar := city[pos.y][pos.x];
    costInt := cast(i32) costChar;
    return costInt - 48;
}

getPathFromPrevChain :: (city: [] str, targetPos: Pos, prev: &Map(Pos, Pos)) -> ([] Pos, i32) {
    path := array.make(Pos);
    pathCost := 0;
    u := targetPos;
    while map.has(prev, u) {
        path << u;
        pathCost += getCityCost(city, u);
        u = map.get(prev, u)->unwrap();
    }
    if !array.empty(path) {
        // Add the start node to the path
        path << u;
        pathCost += getCityCost(city, u);
    }

    // Reverse the path
    array.reverse(path);

    return path, pathCost;
}

Direction :: enum {
    NORTH; SOUTH; EAST; WEST; UNKNOWN;
}
#inject
Direction.hash :: (d: Direction) -> u32 {
    return hash.hash(cast(u32) d);
}
#overload
hash.hash :: (d: Direction) -> u32 {
    return hash.hash(cast(u32) d);
}
CrucibleState :: struct {
    pos: Pos;
    direction: Direction;
    numSteps: i32;
    distance: i32;
}
#operator == (p1: CrucibleState, p2: CrucibleState) -> bool {
    return p1.pos == p2.pos && p1.direction == p2.direction && p1.numSteps == p2.numSteps;
}
#inject
CrucibleState.hash :: (p: CrucibleState) -> u32 {
    return 31 * hash.hash(p.pos) * hash.hash(p.direction) * hash.hash(p.numSteps);
}
#overload
hash.hash :: (p: CrucibleState) -> u32 {
    return 31 * hash.hash(p.pos) * hash.hash(p.direction) * hash.hash(p.numSteps);
}

getDirection :: (curPos: Pos, nextPos: Pos) -> Direction {
    if curPos.y > nextPos.y {
        return Direction.NORTH;
    }
    if curPos.y < nextPos.y {
        return Direction.SOUTH;
    }
    if curPos.x < nextPos.x {
        return Direction.EAST;
    }
    return Direction.WEST;
}

// getShortestPath :: (city: [] str, startPos: Pos, targetPos: Pos) -> i32 {

//     distances := map.make(Pos, i32);
//     visited := set.make(CrucibleState);
//     prev := map.make(Pos, Pos);

//     map.put(&distances, startPos, getCityCost(city, startPos));
//     queue := heap.make(CrucibleState, (p1, p2, [&distances]) => compareStatesByDistance(p1, p2, distances));

//     queue << CrucibleState.{startPos, Direction.NORTH, 1}; // Pretend we arrived at 0,0 going north because that will force a "direction change"

//     while !array.empty(queue.data) {
//         curState := heap.remove_top(&queue);
//         curDirection := curState.direction;
//         curDistance := map.get(&distances, curState.pos)->value_or(MAX_INT);

//         printf("Cur state: {}, distance: {}\n", curState, curDistance);

//         neighbours := getNeighbours(curState.pos);
//         for neighbour: neighbours {
//             neighbourDirection := getDirection(curState.pos, neighbour);
//             neighbourState: CrucibleState;
//             if neighbourDirection != curDirection {
//                 neighbourState = CrucibleState.{neighbour, neighbourDirection, 1};
//             } else {
//                 neighbourState = CrucibleState.{neighbour, neighbourDirection, curState.numSteps + 1};
//             }
//             if (neighbour.x >= 0 && neighbour.y >= 0 && neighbour.x < city[0].length && neighbour.y < city.length) {
//                 if set.has(&visited, neighbourState) {
//                     printf("Already visited: {}\n", neighbourState);
//                 } else {
//                     if neighbourState.numSteps <= 3 {
//                         blockCost := getCityCost(city, neighbour);
//                         neighbourDistance := curDistance + blockCost;

//                         if neighbourDistance < map.get(&distances, neighbour)->value_or(MAX_INT) {
//                             printf("Recording distance to position: {}, distance: {}\n", neighbour, neighbourDistance);
//                             map.put(&distances, neighbour, neighbourDistance);
//                             map.put(&prev, neighbour, neighbourState.pos);
//                         }
//                         printf("Adding neighbour state to queue: {}. (queue size: {})\n", neighbourState, queue.data.count);
//                         queue << neighbourState;
//                     }
//                 }
//             }
//         }

//         set.insert(&visited, curState);

//         println("Cur distances :");

//         for y: 0 .. city.count {
//             for x: 0 .. city[0].count {
//                 distance := map.get(&distances, Pos.{x ,y})->value_or(MAX_INT);
//                 if distance < 10 {
//                     printf("0{} ", distance);
//                 } elseif distance < 100 {
//                     printf("{} ", distance);
//                 } else {
//                     printf("XX ", distance);
//                 }
//             }
//             println("");
//         }
//     }

//     path, pathCost := getPathFromPrevChain(city, targetPos, &prev);

//     printf("Path len: {}, cost: {}, path: {}\n", path.length, pathCost, path);

//     for p: path {
//         printf("({}, {}): {}\n", p.x, p.y, city[p.y][p.x]);
//     }

//     return pathCost;
// }

compareStatesByDistance :: (p1: CrucibleState, p2: CrucibleState, distances: &Map(Pos, i32)) -> i32 {
    return cmp(p1.distance, p2.distance);
}


getPathCost :: (city: [] str, path: [] Pos) -> i32 {
    return iter.as_iter(path)
        |> iter.map((p, [city]) => getCityCost(city, *p))
        |> iter.fold(0, (n, a) => a + n);
}


// solve_part_1 :: () -> str {
//     city := string.split(exampleInput, '\n');
//     shortestPath := getShortestPath(city, Pos.{0, 0}, Pos.{city[0].length - 1, city.length - 1});

//     printf("Shortest path: {}\n", shortestPath);

//     return toStr(shortestPath);
// }


// solve_part_2 :: () -> str {
//     return "";
// }


exampleInput := """2413432311323
3215453535623
3255245654254
3446585845452
4546657867536
1438598798454
4457876987766
3637877979653
4654967986887
4564679986453
1224686865563
2546548887735
4322674655533""";


city: [] str;
startPos: Pos;
targetPos: Pos;
distances : Map(Pos, i32);
visited : Set(CrucibleState);
prev : Map(Pos, Pos);
queue : heap.Heap(CrucibleState);

// Variables used for visualisation
lastCrucibleState : CrucibleState;
recentlyUpdatedDistances: [..] Pos;

numSteps := 0;


mutex := 0;
lock :: () {
    // Wait until the mutex is 0 as that means it's safe to render or update the game state
    // If it is 0 then set the value to 1 and exit the loop
    while __atomic_cmpxchg(&mutex, 0, 1) != 0 {
        __atomic_wait(&mutex, 1);
    }
}

unlock :: () {
    // Set the mutex back to 0 and notify any threads that are waiting
    __atomic_store(&mutex, 0);
    __atomic_notify(&mutex);
}

setup :: () {
    if numSteps == 0 {
        lock();

        // Set the params
        city = string.split(exampleInput, '\n');
        startPos = Pos.{0, 0};
        targetPos = Pos.{city[0].length - 1, city.length - 1};

        // Initialise the search
        distances = map.make(Pos, i32);
        visited = set.make(CrucibleState);
        prev = map.make(Pos, Pos);
        map.put(&distances, startPos, getCityCost(city, startPos));
        queue = heap.make(CrucibleState, (p1, p2, [&distances]) => compareStatesByDistance(p1, p2, distances));
        queue << CrucibleState.{startPos, Direction.NORTH, 1}; // Pretend we arrived at 0,0 going north because that will force a "direction change"

        unlock();
    }
}

#export "solve" solve
solve :: () {
    setup();
    while !array.empty(queue.data) {
        getShortestPathStep();
    }
    numSteps += 1;
}

#export "step" step
step :: () {
    setup();
    if !array.empty(queue.data) {
        getShortestPathStep();
    }
    numSteps += 1;
}


getShortestPathStep :: () {
    lock();
    recentlyUpdatedDistances = array.make(Pos);

    curState := heap.remove_top(&queue);
    curDirection := curState.direction;
    // curDistance := map.get(&distances, curState.pos)->value_or(MAX_INT);
    curDistance := curState.distance;

    printf("Cur state: {}, distance: {}\n", curState, curDistance);

    neighbours := getNeighbours(curState.pos);
    for neighbour: neighbours {
        neighbourDirection := getDirection(curState.pos, neighbour);
        blockCost := getCityCost(city, neighbour);
        neighbourDistance := curDistance + blockCost;
        neighbourState: CrucibleState;
        if neighbourDirection != curDirection {
            neighbourState = CrucibleState.{neighbour, neighbourDirection, 1, neighbourDistance};
        } else {
            neighbourState = CrucibleState.{neighbour, neighbourDirection, curState.numSteps + 1, neighbourDistance};
        }
        if (neighbour.x >= 0 && neighbour.y >= 0 && neighbour.x < city[0].length && neighbour.y < city.length) {
            if set.has(&visited, neighbourState) {
                printf("Already visited: {}\n", neighbourState);
            } else {
                if neighbourState.numSteps <= 3 {
                    // blockCost := getCityCost(city, neighbour);
                    // neighbourDistance := curDistance + blockCost;

                    if neighbourDistance < map.get(&distances, neighbour)->value_or(MAX_INT) {
                        printf("Recording distance to position: {}, distance: {}\n", neighbour, neighbourDistance);
                        map.put(&distances, neighbour, neighbourDistance);
                        map.put(&prev, neighbour, curState.pos);
                        recentlyUpdatedDistances << neighbour;
                    }
                    printf("Adding neighbour state to queue: {}. (queue size: {})\n", neighbourState, queue.data.count);
                    queue << neighbourState;
                }
            }
        }
        unlock();
    }

    printf("Prev map is: {}\n", prev);

    lastCrucibleState = curState;

    set.insert(&visited, curState);
}

renderCell :: (posX: i32, posY: i32, distance: i32, colour: Colour) {
    if distance < 10 {
        renderChar('0', posX, posY, colour);
        renderChar(cast(u8) ('0' + distance), posX + 10, posY, colour);
    } elseif distance < 100 {
        renderChar(cast(u8) ('0' + distance / 10), posX, posY, colour);
        renderChar(cast(u8) ('0' + distance % 10), posX + 10, posY, colour);
    } else {
        renderChar('X', posX, posY, colour);
        renderChar('X', posX + 10, posY, colour);
    }
}


// getPrevState :: (state: CrucibleState) -> CrucibleState {
//     switch state.direction {
//         case Direction.NORTH {
//             return map.get(&prev, Pos.{state.pos.x, state.pos.y + 1})->value_or(CrucibleState.{Pos.{0, 0}, Direction.NORTH, 0, 0});
//         }
//         case Direction.SOUTH {
//             return map.get(&prev, Pos.{state.pos.x, state.pos.y - 1})->value_or(CrucibleState.{Pos.{0, 0}, Direction.NORTH, 0, 0});
//         }
//         case Direction.EAST {
//             return map.get(&prev, Pos.{state.pos.x - 1, state.pos.y})->value_or(CrucibleState.{Pos.{0, 0}, Direction.NORTH, 0, 0});
//         }
//         case Direction.WEST {
//             return map.get(&prev, Pos.{state.pos.x + 1, state.pos.y})->value_or(CrucibleState.{Pos.{0, 0}, Direction.NORTH, 0, 0});
//         }
//     }
// }

#export "render" render
render :: (time: i64) -> i32 {

    lock();

    // Clear the canvas
    clear();

    fontColour := Colour.{255, 50, 50, 0};
    recentlyUpdatedColour := Colour.{0, 50, 255, 0};
    curColour := Colour.{100, 175, 75, 0};

    if numSteps > 0 {
        // Render all calculated distances
        for y: 0 .. city.count {
            for x: 0 .. city[0].count {
                pos := Pos.{x, y};

                distance := map.get(&distances, pos)->value_or(MAX_INT);

                posX := 120 + x * 30;
                posY := 120 + y * 25;

                if pos == lastCrucibleState.pos {
                    renderCell(posX, posY, lastCrucibleState.distance, curColour);
                } elseif array.contains(recentlyUpdatedDistances, pos) {
                    renderCell(posX, posY, distance, recentlyUpdatedColour);
                } else {
                    renderCell(posX, posY, distance, fontColour);
                }
            }
        }

        // Render most recent state

        posX := 120 + lastCrucibleState.pos.x * 30;
        posY := 120 + lastCrucibleState.pos.y * 25;

        // Draw last pos
        renderBox(posX, posY, 20, 17, Colour.{50, 200, 0, 255});

        totalPathLength := 0;
        // Draw the path to the last pos
        // printf("Cur state is: {}\n", lastCrucibleState);
        // prevState := getPrevState(lastCrucibleState);
        // printf("Cur state is: {}\n", lastCrucibleState);

        prevPos := map.get(&prev, lastCrucibleState.pos)->value_or(Pos.{0, 0});
        while prevPos != Pos.{0, 0} && totalPathLength < 10 {
            posX := 120 + prevPos.x * 30;
            posY := 120 + prevPos.y * 25;
            renderBox(posX, posY, 20, 17, Colour.{100, 150, 75, 255});
            totalPathLength += 1;
            // prevState = getPrevState(prevState);
            prevPos = map.get(&prev, prevPos)->value_or(Pos.{0, 0});
            // printf("Prev state is: {}\n", prevState);
        }
        renderBox(120, 120, 20, 17, Colour.{100, 150, 75, 255});
        // Draw arrow
        switch lastCrucibleState.direction {
            case Direction.NORTH {
                renderArrow(posX + 5, posY + 21, lastCrucibleState.direction, Colour.{50, 200, 0, 100});
            }
            case Direction.SOUTH {
                renderArrow(posX + 5, posY - 5, lastCrucibleState.direction, Colour.{50, 200, 0, 100});
            }
            case Direction.EAST {
                renderArrow(posX - 8, posY + 8, lastCrucibleState.direction, Colour.{50, 200, 0, 100});
            }
            case Direction.WEST {
                renderArrow(posX + 18, posY + 8, lastCrucibleState.direction, Colour.{50, 200, 0, 100});
            }
        }

    }

    unlock();
    return 0;
}


main :: () {

}